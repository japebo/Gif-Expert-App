{"version":3,"sources":["components/AddCategory.js","components/GifGridItem.js","helpers/getGifs.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","GifGridItem","title","url","className","src","alt","getGifs","category","a","encodeURI","fetch","resp","json","data","gifs","map","img","id","images","downsized_medium","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"uMAEaA,EAAc,SAAC,GAAyB,IAAtBC,EAAqB,EAArBA,cAE3B,EAAoCC,mBAAS,IAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KAkBA,OACI,sBAAMC,SAZW,SAACC,GAClBA,EAAEC,iBAEEJ,EAAWK,OAAOC,OAAS,IAC3BR,GAAe,SAAAS,GAAI,OAAKP,GAAL,mBAAoBO,OAEvCN,EAAc,MAMlB,SACG,uBACKO,KAAK,OACLC,MAAQT,EACRU,SArBc,SAAEP,GAExBF,EAAcE,EAAEQ,OAAOF,a,QCNlBG,EAAc,SAAC,GAAkB,IAAjBC,EAAgB,EAAhBA,MAAOC,EAAS,EAATA,IAIhC,OACI,sBAAKC,UAAU,yCAAf,UACI,qBAAKC,IAAKF,EAAKG,IAAKJ,IACpB,4BAAIA,Q,uBCRHK,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAEbN,EAFa,iDAEmCO,UAAUF,GAF7C,+DAGAG,MAAMR,GAHN,cAGbS,EAHa,gBAIEA,EAAKC,OAJP,uBAIZC,EAJY,EAIZA,KAEDC,EAAOD,EAAKE,KAAK,SAAAC,GAAQ,IAAD,EAC1B,MAAO,CACHC,GAAID,EAAIC,GACRhB,MAAOe,EAAIf,MACXC,IAAG,UAAEc,EAAIE,cAAN,aAAE,EAAYC,iBAAiBjB,QAVvB,kBAcZY,GAdY,4CAAH,sDCKPM,EAAU,SAAC,GAAgB,IAAfb,EAAc,EAAdA,SAErB,ECLwB,SAACA,GAEzB,MAA0BpB,mBAAS,CAC/B0B,KAAM,GACNQ,SAAS,IAFb,mBAAOC,EAAP,KAAcC,EAAd,KAaA,OARAC,qBAAU,WACNlB,EAAQC,GAAUkB,MAAM,SAAAC,GAAI,OAAIH,EAAS,CACjCV,KAAMa,EACNL,SAAS,SAElB,CAACd,IAGGe,EDVwBK,CAAcpB,GAAjCW,EAAZ,EAAOL,KAAaQ,EAApB,EAAoBA,QAEpB,OACI,qCACI,qBAAIlB,UAAU,oCAAd,cAAoDI,EAApD,OACEc,GAAW,mBAAGlB,UAAU,mCAAb,qBACb,qBAAKA,UAAU,YAAf,SAEQe,EAAOH,KAAK,SAAAC,GAAG,OAEX,aADA,CACC,EAAD,eAA8BA,GAAZA,EAAIC,aEdjCW,EAAe,WAGxB,MAAoCzC,mBAAS,CAAC,cAA9C,mBAAO0C,EAAP,KAAmB3C,EAAnB,KASA,OACI,qCACI,8CACA,cAAC,EAAD,CAAaA,cAAeA,IAC5B,uBACA,6BAEQ2C,EAAWd,KAAK,SAAAR,GAAQ,OAEpB,aADA,CACC,EAAD,CAAwBA,SAAUA,GAApBA,Y,MCpBtCuB,IAASC,OAAQ,cAAC,EAAD,IAAkBC,SAASC,eAAe,W","file":"static/js/main.2159a831.chunk.js","sourcesContent":["import React, { useState } from 'react'\r\n\r\nexport const AddCategory = ( { setCategories } ) => {\r\n\r\n    const [inputValue, setInputValue] = useState('');\r\n\r\n    const handleInputChange = ( e ) => {\r\n        // console.log(e.target.value);\r\n        setInputValue(e.target.value); //e.target.value contiene el valor tras ocurrir el evento de presion de una tecla.\r\n    }\r\n\r\n    const handleSubmit = (e) => {\r\n        e.preventDefault(); //evita que se recargue la página, que es el comportamiento por defecto tras el evento.\r\n\r\n        if (inputValue.trim().length > 2) {\r\n            setCategories( cats => [inputValue, ...cats]); //opción preferida, que es usando un callback function, pues setCategories tiene acceso al esatdo actual de las 'categories', accesible en este caso a través del argumento 'cats' que pasa la propia función.\r\n            // setCategories( [inputValue, ...categories]); //una alternativa a la línea de arriba es esta, que hace lo mismo. Para usarla habría que pasarle la propiedad 'categories' (o el nombre que se desee, solo debemos asegurarnos de que coincidan el nombre de las propiedad pasada y el argumento que se desestructura luego en el functional component AddCategory) al llamado al componente AddCategory dentro del componente GifExpertApp (de esta forma: <AddCategory setCategories={setCategories} categories={categories}/>); además de desestructurar la nueva propiedad que es pasada de un componente a otro, llamada categories probablemente (de esta forma: export const AddCategory = ( { categories, setCategories  } ) => {...}). \r\n            setInputValue('');\r\n        };\r\n        // console.log('Submit hecho');\r\n    };\r\n\r\n    return (\r\n        <form onSubmit = {handleSubmit}>\r\n           <input\r\n                type=\"text\"\r\n                value={ inputValue }\r\n                onChange = {handleInputChange}\r\n           /> \r\n        </form>\r\n    )\r\n}\r\n","import React from 'react'\r\n\r\nexport const GifGridItem = ({title, url}) => {\r\n    \r\n    //  console.log(title, url);\r\n\r\n    return (\r\n        <div className=\"card animate__animated animate__fadeIn\">\r\n            <img src={url} alt={title}/>\r\n            <p>{title}</p>\r\n        </div>\r\n    )\r\n}\r\n","\r\nexport const getGifs = async (category) => {\r\n        \r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=10&api_key=ruKxqzVdhxchaOgAAYOTeDgvB3MMBtVT`;\r\n    const resp = await fetch(url);\r\n    const {data} = await resp.json();\r\n    \r\n    const gifs = data.map( img => { //en la constante gif hay un arreglo de 10 objetos. cada uno contiene 3 propiedades.\r\n        return { \r\n            id: img.id,\r\n            title: img.title,\r\n            url: img.images?.downsized_medium.url \r\n        };\r\n    });\r\n  \r\n    return gifs;\r\n}","\r\nimport React from 'react';\r\n// import {useState, useEffect} from 'react';\r\nimport { GifGridItem } from './GifGridItem';\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\n\r\nexport const GifGrid = ({category}) => {\r\n\r\n    const {data:images, loading} = useFetchGifs( category );\r\n\r\n    return (\r\n        <>\r\n            <h3 className=\"animate__animated animate__fadeIn\"> {category} </h3>\r\n            { loading && <p className=\"animate__animated animate__flash\">Loading</p>}\r\n            <div className=\"card-grid\">\r\n                {\r\n                    images.map( img => (\r\n                        // <GifGridItem key={img.id} img={img} />  //opción 1\r\n                        <GifGridItem key={img.id} {...img} />   //opción 2 \r\n                        ))  \r\n                    }\r\n            </div>\r\n        </>\r\n    )\r\n}\r\n","import { useEffect, useState } from \"react\";\r\nimport {getGifs} from '../helpers/getGifs'\r\n\r\nexport const useFetchGifs = (category) => { //this is a custom hook\r\n\r\n    const [state, setState] = useState({\r\n        data: [],\r\n        loading: true\r\n    });\r\n\r\n    useEffect(() => { \r\n        getGifs(category).then( imgs => setState({\r\n                data: imgs,\r\n                loading: false    \r\n            }) ); //helper that returns a promise\r\n    }, [category]); //saying that if category changes (that will not), the instrucción inside useEffect will be re-runned.\r\n    // en el hook de arriba, la función del primer argumento no puede ser async, porque espera algo síncrono    \r\n\r\n    return state;\r\n}\r\n","import React, { useState } from 'react'\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\nexport const GifExpertApp = () => {\r\n\r\n    // const [categories, setCategories] = useState(['One Punch', 'Samurai X', 'Dragon Ball']);\r\n    const [categories, setCategories] = useState(['One Punch']);\r\n    \r\n    // const handleAdd = () => {\r\n    //     // categories.push('HunterXHunter'); //no sirve para nuestro propósito de agregar un nuevo elemento al array que sea renderizable, lo que hace es agregar un nuevo elemento al objeto array, pero sin actualizarlo en el Hook useState. \r\n    //     // setCategories('HunterXHunter'); //tampoco sirve de esta forma pues lo que hace es sobreescribir \"categories\" con un elemento de tipo string.\r\n    //     setCategories([...categories, 'HunterXHunter']); //opción 1 (utilizando el operador spread)\r\n    //     // setCategories( () => [...categories, 'HunterXHunter']); //opción 2\r\n    // };\r\n\r\n    return (\r\n        <>\r\n            <h2>GifExpertApp</h2>\r\n            <AddCategory setCategories={setCategories}/> \r\n            <hr/>\r\n            <ol>\r\n                {\r\n                    categories.map( category => ( \r\n                        // return <li key={category}> {category} </li>; //'key' debe ser único, porque será la forma de referirnos a un elemento específico. NOTA: no se debe usar el índice que proporciona el segundo argumento de la función map (que en este caso se omite, porque no se necesita).\r\n                        <GifGrid key={category} category={category}/>\r\n                    ))\r\n                }\r\n            </ol>\r\n        </>\r\n    )\r\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { GifExpertApp } from './GifExpertApp';\nimport './index.css';\n\nReactDOM.render( <GifExpertApp />, document.getElementById('root'));"],"sourceRoot":""}